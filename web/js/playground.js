/* 
 * App specific functions.  This is for unique functionality and application initialization.  
 */


// Identify playground configuration.  Will be available as github CDN.
// import { default as PLAYGROUND } from 'https://centerfordigitalhumanities.github.io/rerum-playground/web/js/config.js'
    
// Playground scripting utilities.  Will be available as github CDN.
import { default as UTILS } from 'https://centerfordigitalhumanities.github.io/rerum-playground/web/js/utilities.js'

import PLAYGROUND from './config.js';
import ToolsCatalog from './tools.js';

const RECENTLY_USED_KEY = 'recentlyUsedTools';

/**
 * Retrieve recently used tools from local storage.
 */
function getRecentlyUsedTools() {
    const recentTools = localStorage.getItem(RECENTLY_USED_KEY);
    return recentTools ? JSON.parse(recentTools) : [];
}

/** 
 * Save recently used tools to local storage.
 */
function saveRecentlyUsedTools(recentTools) {
    localStorage.setItem(RECENTLY_USED_KEY, JSON.stringify(recentTools));
}

/**
 * Update recently used tools, move the clicked tool to the top.
 */
function updateRecentlyUsedTools(clickedTool) {
    const recentTools = getRecentlyUsedTools();
    const existingIndex = recentTools.findIndex(tool => tool.label.toLowerCase() === clickedTool.label.toLowerCase());

    console.log('clicked tool:', clickedTool);
    console.log('existing index of tool in recent list:', existingIndex);
    // remove the tools if it already exists in the list
    if (existingIndex !== -1) {
        recentTools.splice(existingIndex, 1);
    }

    // add the clicked tool to the top of the list
    recentTools.unshift(clickedTool);

    const toolIndex = ToolsCatalog.findIndex(tool => tool.label.toLowerCase() === clickedTool.label.toLowerCase());
    // console.log('tool index in toolscatalog:', toolIndex);

    // if (toolIndex !== -1) {
    //     const [tool] = ToolsCatalog.splice(toolIndex, 1);
    //     ToolsCatalog.unshift(tool);
    //     console.log('updated toolscatalog:', ToolsCatalog);
    // }

    // save only the top 3 recent tools
    saveRecentlyUsedTools(recentTools.slice(0, 3));

    console.log('updated recently used tools:', getRecentlyUsedTools());
}

/**
*  Landing behavior for interfaces.  This should populate the set of available interfaces to the DOM.
*/
function initializeInterfaces(config) {
    return new Promise((res) => {
        let setContainer = document.getElementById(config.id)
        Array.from(config.catalog).forEach(inter => {
            setContainer.innerHTML += UTILS.thumbnailGenerator(inter)
        })
        UTILS.broadcast(undefined, PLAYGROUND.EVENTS.LOADED, setContainer, {})
        /**
         * Really each render should be a promise and we should return a Promise.all() here of some kind.
         * That would only work if PlaygroundRender resulted in a Promise where we could return Promise.all(renderPromises).
         */
        setTimeout(res, 200) //A small hack to ensure all the HTML generated by processing the views enters the DOM before this says it has resolved.
    })
}

/**
*  Landing behavior for technologies.  This should populate the technologies to the DOM.
*/
function initializeTechnologies(config) {
    return new Promise((res) => {
        let setContainer = document.getElementById(config.id)
        Array.from(config.catalog).forEach(tech => {
            setContainer.innerHTML += UTILS.thumbnailGenerator(tech)
        })
        UTILS.broadcast(undefined, PLAYGROUND.EVENTS.LOADED, setContainer, {})
        /**
         * Really each render should be a promise and we should return a Promise.all() here of some kind.
         * That would only work if PlaygroundRender resulted in a Promise where we could return Promise.all(renderPromises).
         */
        setTimeout(res, 200) //A small hack to ensure all the HTML generated by processing the views enters the DOM before this says it has resolved.
    })
}

/**
 * Render tools, higlighting recently used ones.
 */
function renderTools() {
    const toolSetContainer = document.getElementById('tool_set');

    if (!toolSetContainer) {
        console.error("Tool set container not found.");
        return;
    }

    toolSetContainer.innerHTML = '';

    const recentTools = getRecentlyUsedTools();
    // sort ToolsCatalog based on recent usage
    const sortedTools = [...ToolsCatalog].sort((a, b) => {
        const indexA = recentTools.findIndex(tool => tool.label === a.label);
        const indexB = recentTools.findIndex(tool => tool.label === b.label);
        return indexA === -1 ? 1 : indexB === -1? -1 : indexA - indexB;
    });
    
    // const toolsWrapper = document.createElement('div');

    sortedTools.forEach((tool, index) => {
        // console.log('Tool:', tool.label, 'Index:', index);
        // console.log('Before click:', ToolsCatalog);
        // console.log(`Tool clicked: ${tool.label}, Index: ${ToolsCatalog.indexOf(tool)}`);
        // const isRecentlyUsed = index < 3 ? `<span class="recent-badge">Recently used</span>` : '';
        const isRecentlyUsed = recentTools.findIndex(recentTool => recentTool.label === tool.label) !== -1;

        const toolHTML = `
            <a href="${tool.view}" target="_blank" class="catalogEntry">
                <figure class="thumb">
                    <label>${tool.label}</label>
                    <img src="${tool.icon}" alt="${tool.label}" />
                    <figcaption>${tool.description}</figcaption>
                </figure>
                <div class="recent-badge" id="badge-${index}" style="display: ${isRecentlyUsed && index < 3 ? 'block' : 'none'};">Recently used</div>
            </a>
        `;
        toolSetContainer.innerHTML += toolHTML;

        toolSetContainer.querySelector(`a.catalogEntry[href='${tool.view}']`).addEventListener('click', (e) => {
            e.preventDefault();
            console.log('clicked tool: ${tool.label}');
            updateRecentlyUsedTools(tool);
            renderTools();
        });
    });

    // toolSetContainer.appendChild(toolsWrapper);
}

/**
 * Update tool order when a tool is clicked.
 */
window.updateToolOrder = function(toolLabel) {
    const clickedTool = ToolsCatalog.find(tool => tool.label === toolLabel);
    if (clickedTool) {
        updateRecentlyUsedTools(clickedTool);
        renderTools(); // re-render the tools after updating the order
    }
}

document.addEventListener('DOMContentLoaded', () => {
/**
*  These are promises so we can control the chaining how we like, if necessary.
*/
    try {
        //initializeTools(PLAYGROUND.TOOLS)
        initializeInterfaces(PLAYGROUND.INTERFACES)
        initializeTechnologies(PLAYGROUND.TECHNOLOGIES)

        renderTools();
    } catch (err) {
        console.error("Error initializing the playground: ", err);
    }
});    